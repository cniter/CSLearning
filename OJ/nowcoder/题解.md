## [栈和排序](https://www.nowcoder.com/practice/95cb356556cf430f912e7bdf1bc2ec8f?tpId=117)
相当于一个后缀数组的变种题，令 max[i] 为 i 到数组尾中的最大值，maxIndex[i] 为最大值对应的下标，因为要出栈顺序为字典序最大，所以最近出栈的一定为剩下还没入栈元素的最大值，设 top 为栈顶元素，若 top 比剩下元素都大，则 top 出栈，否则剩下元素出栈，如此循环比较，直到栈为空，出栈顺序即为字典序最大。具体代码为[栈和排序.js](./栈和排序.js)

## [输出二叉树的右视图](https://www.nowcoder.com/practice/c9480213597e45f4807880c763ddd5f0?tpId=117)
该题相当于两道题：一个是根据前序遍历和中序遍历构建二叉树；另一个才是输出二叉树的右视图。根据前序和中序建树一般采用递归，前序遍历可确定父节点，而中序遍历可确定左右子树，先根据前序遍历的起点找到中序遍历对应节点的位置，得到递归构建左右子树中序遍历的起点和终点，中序遍历对应节点的两边即为左右子树，根据两边节点的数目可直接得出递归构建左右子树前序遍历的起点和终点，如此递归，直到终点比起点小，可完成二叉树的构建。二叉树的右视图是指从右往左看一颗二叉树能看到的节点，即层次遍历每层最后一个节点，二叉树的层次遍历一般通过一个辅助队列进行遍历，队列尾弹出一个节点，同时将该节点的所有子节点放入队列中，如此，直到队列为空，完成二叉树的层次遍历，但这种方式无法直接得到弹出的节点是否为该层的最后一个节点（通过进队列时同时放入层级信息可判断是否为该层的最后一个节点），所以需要每层单独进行遍历，同时收集下一层的遍历信息，如此可直接得到每层的最后一个节点。具体代码为[输出二叉树的右视图.js](./输出二叉树的右视图.js)

## [最大正方形](https://www.nowcoder.com/practice/0058c4092cec44c2975e38223f10470e?tpId=117)
该题相当于二维数组的前缀和，设 sumMatrix[i+1][j+1] 为二维数组 matrix 从 (i,j) 到 (0,0) 位置构成的子二维数组中元素之和，sumMatrix 中所有元素都初始化为 0，则 sumMatrix[i+1][j+1] = sumMatrix[i+1][j] + sumMatrix[i][j+1] - sumMatrix[i][j] + matrix[i][j]。根据 sumMatrix 可很快得出 matrix 任意矩形块子数组之和，设以 (i,j) 为起点，矩形块高为 h，宽为 w，矩形块中元素之和为 sum, 则 sum = sumMatrix[i+h][j+w] - sumMatrix[i+h][j] - sumMatrix[i][j+w] + sumMatrix[i][j]。由于题中是正方形，若设正方形边长为 d，则只需要满足 sum === d * d，即可判断二维数组中是否存在边长为 d 的正方形，若存在则 d += 1，继续判断，直到不满足条件或达到 d 的最大值为止。具体代码为[最大正方形.js](./最大正方形.js)。


